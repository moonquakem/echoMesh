// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace echomesh {
class ChatMsg;
struct ChatMsgDefaultTypeInternal;
extern ChatMsgDefaultTypeInternal _ChatMsg_default_instance_;
class EchoMsg;
struct EchoMsgDefaultTypeInternal;
extern EchoMsgDefaultTypeInternal _EchoMsg_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class RoomAction;
struct RoomActionDefaultTypeInternal;
extern RoomActionDefaultTypeInternal _RoomAction_default_instance_;
class RoomActionResponse;
struct RoomActionResponseDefaultTypeInternal;
extern RoomActionResponseDefaultTypeInternal _RoomActionResponse_default_instance_;
class VoiceAnnounce;
struct VoiceAnnounceDefaultTypeInternal;
extern VoiceAnnounceDefaultTypeInternal _VoiceAnnounce_default_instance_;
}  // namespace echomesh
PROTOBUF_NAMESPACE_OPEN
template<> ::echomesh::ChatMsg* Arena::CreateMaybeMessage<::echomesh::ChatMsg>(Arena*);
template<> ::echomesh::EchoMsg* Arena::CreateMaybeMessage<::echomesh::EchoMsg>(Arena*);
template<> ::echomesh::LoginRequest* Arena::CreateMaybeMessage<::echomesh::LoginRequest>(Arena*);
template<> ::echomesh::LoginResponse* Arena::CreateMaybeMessage<::echomesh::LoginResponse>(Arena*);
template<> ::echomesh::RoomAction* Arena::CreateMaybeMessage<::echomesh::RoomAction>(Arena*);
template<> ::echomesh::RoomActionResponse* Arena::CreateMaybeMessage<::echomesh::RoomActionResponse>(Arena*);
template<> ::echomesh::VoiceAnnounce* Arena::CreateMaybeMessage<::echomesh::VoiceAnnounce>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace echomesh {

enum MsgType : int {
  MT_UNKNOWN = 0,
  MT_LOGIN_REQUEST = 1,
  MT_LOGIN_RESPONSE = 2,
  MT_CHAT_MSG = 3,
  MT_ROOM_ACTION = 4,
  MT_VOICE_ANNOUNCE = 5,
  MT_ROOM_ACTION_RESPONSE = 7,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = MT_UNKNOWN;
constexpr MsgType MsgType_MAX = MT_ROOM_ACTION_RESPONSE;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum StatusCode : int {
  SC_OK = 0,
  SC_ERROR = 1,
  SC_ROOM_NOT_FOUND = 101,
  SC_USER_NOT_IN_ROOM = 102,
  StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StatusCode_IsValid(int value);
constexpr StatusCode StatusCode_MIN = SC_OK;
constexpr StatusCode StatusCode_MAX = SC_USER_NOT_IN_ROOM;
constexpr int StatusCode_ARRAYSIZE = StatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusCode_descriptor();
template<typename T>
inline const std::string& StatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusCode_descriptor(), enum_t_value);
}
inline bool StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusCode>(
    StatusCode_descriptor(), name, value);
}
enum RoomActionType : int {
  RA_UNKNOWN = 0,
  RA_CREATE = 1,
  RA_JOIN = 2,
  RA_LEAVE = 3,
  RoomActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RoomActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RoomActionType_IsValid(int value);
constexpr RoomActionType RoomActionType_MIN = RA_UNKNOWN;
constexpr RoomActionType RoomActionType_MAX = RA_LEAVE;
constexpr int RoomActionType_ARRAYSIZE = RoomActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoomActionType_descriptor();
template<typename T>
inline const std::string& RoomActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoomActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoomActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoomActionType_descriptor(), enum_t_value);
}
inline bool RoomActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoomActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoomActionType>(
    RoomActionType_descriptor(), name, value);
}
// ===================================================================

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:echomesh.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "echomesh.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:echomesh.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:echomesh.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "echomesh.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kUserIdFieldNumber = 2,
    kStatusCodeFieldNumber = 1,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int64 user_id = 2;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // .echomesh.StatusCode status_code = 1;
  void clear_status_code();
  ::echomesh::StatusCode status_code() const;
  void set_status_code(::echomesh::StatusCode value);
  private:
  ::echomesh::StatusCode _internal_status_code() const;
  void _internal_set_status_code(::echomesh::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:echomesh.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int64_t user_id_;
    int status_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ChatMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:echomesh.ChatMsg) */ {
 public:
  inline ChatMsg() : ChatMsg(nullptr) {}
  ~ChatMsg() override;
  explicit PROTOBUF_CONSTEXPR ChatMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMsg(const ChatMsg& from);
  ChatMsg(ChatMsg&& from) noexcept
    : ChatMsg() {
    *this = ::std::move(from);
  }

  inline ChatMsg& operator=(const ChatMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMsg& operator=(ChatMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMsg* internal_default_instance() {
    return reinterpret_cast<const ChatMsg*>(
               &_ChatMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChatMsg& a, ChatMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatMsg& from) {
    ChatMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "echomesh.ChatMsg";
  }
  protected:
  explicit ChatMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 2,
    kContentFieldNumber = 3,
    kUserIdFieldNumber = 1,
  };
  // string room_id = 2;
  void clear_room_id();
  const std::string& room_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_id();
  PROTOBUF_NODISCARD std::string* release_room_id();
  void set_allocated_room_id(std::string* room_id);
  private:
  const std::string& _internal_room_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_id(const std::string& value);
  std::string* _internal_mutable_room_id();
  public:

  // string content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // int64 user_id = 1;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:echomesh.ChatMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int64_t user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class RoomAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:echomesh.RoomAction) */ {
 public:
  inline RoomAction() : RoomAction(nullptr) {}
  ~RoomAction() override;
  explicit PROTOBUF_CONSTEXPR RoomAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomAction(const RoomAction& from);
  RoomAction(RoomAction&& from) noexcept
    : RoomAction() {
    *this = ::std::move(from);
  }

  inline RoomAction& operator=(const RoomAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomAction& operator=(RoomAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomAction* internal_default_instance() {
    return reinterpret_cast<const RoomAction*>(
               &_RoomAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoomAction& a, RoomAction& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomAction& from) {
    RoomAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "echomesh.RoomAction";
  }
  protected:
  explicit RoomAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kActionTypeFieldNumber = 1,
  };
  // string room_id = 2;
  void clear_room_id();
  const std::string& room_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_id();
  PROTOBUF_NODISCARD std::string* release_room_id();
  void set_allocated_room_id(std::string* room_id);
  private:
  const std::string& _internal_room_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_id(const std::string& value);
  std::string* _internal_mutable_room_id();
  public:

  // int64 user_id = 3;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // .echomesh.RoomActionType action_type = 1;
  void clear_action_type();
  ::echomesh::RoomActionType action_type() const;
  void set_action_type(::echomesh::RoomActionType value);
  private:
  ::echomesh::RoomActionType _internal_action_type() const;
  void _internal_set_action_type(::echomesh::RoomActionType value);
  public:

  // @@protoc_insertion_point(class_scope:echomesh.RoomAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_id_;
    int64_t user_id_;
    int action_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class RoomActionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:echomesh.RoomActionResponse) */ {
 public:
  inline RoomActionResponse() : RoomActionResponse(nullptr) {}
  ~RoomActionResponse() override;
  explicit PROTOBUF_CONSTEXPR RoomActionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomActionResponse(const RoomActionResponse& from);
  RoomActionResponse(RoomActionResponse&& from) noexcept
    : RoomActionResponse() {
    *this = ::std::move(from);
  }

  inline RoomActionResponse& operator=(const RoomActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomActionResponse& operator=(RoomActionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomActionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomActionResponse* internal_default_instance() {
    return reinterpret_cast<const RoomActionResponse*>(
               &_RoomActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RoomActionResponse& a, RoomActionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomActionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomActionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomActionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomActionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomActionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomActionResponse& from) {
    RoomActionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomActionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "echomesh.RoomActionResponse";
  }
  protected:
  explicit RoomActionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .echomesh.StatusCode status_code = 1;
  void clear_status_code();
  ::echomesh::StatusCode status_code() const;
  void set_status_code(::echomesh::StatusCode value);
  private:
  ::echomesh::StatusCode _internal_status_code() const;
  void _internal_set_status_code(::echomesh::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:echomesh.RoomActionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int status_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class VoiceAnnounce final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:echomesh.VoiceAnnounce) */ {
 public:
  inline VoiceAnnounce() : VoiceAnnounce(nullptr) {}
  ~VoiceAnnounce() override;
  explicit PROTOBUF_CONSTEXPR VoiceAnnounce(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoiceAnnounce(const VoiceAnnounce& from);
  VoiceAnnounce(VoiceAnnounce&& from) noexcept
    : VoiceAnnounce() {
    *this = ::std::move(from);
  }

  inline VoiceAnnounce& operator=(const VoiceAnnounce& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceAnnounce& operator=(VoiceAnnounce&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoiceAnnounce& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoiceAnnounce* internal_default_instance() {
    return reinterpret_cast<const VoiceAnnounce*>(
               &_VoiceAnnounce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VoiceAnnounce& a, VoiceAnnounce& b) {
    a.Swap(&b);
  }
  inline void Swap(VoiceAnnounce* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceAnnounce* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoiceAnnounce* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoiceAnnounce>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoiceAnnounce& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoiceAnnounce& from) {
    VoiceAnnounce::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceAnnounce* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "echomesh.VoiceAnnounce";
  }
  protected:
  explicit VoiceAnnounce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
    kRoomIdFieldNumber = 2,
    kUserIdFieldNumber = 3,
  };
  // string sdp = 1;
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // string room_id = 2;
  void clear_room_id();
  const std::string& room_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_id();
  PROTOBUF_NODISCARD std::string* release_room_id();
  void set_allocated_room_id(std::string* room_id);
  private:
  const std::string& _internal_room_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_id(const std::string& value);
  std::string* _internal_mutable_room_id();
  public:

  // int64 user_id = 3;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:echomesh.VoiceAnnounce)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_id_;
    int64_t user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class EchoMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:echomesh.EchoMsg) */ {
 public:
  inline EchoMsg() : EchoMsg(nullptr) {}
  ~EchoMsg() override;
  explicit PROTOBUF_CONSTEXPR EchoMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EchoMsg(const EchoMsg& from);
  EchoMsg(EchoMsg&& from) noexcept
    : EchoMsg() {
    *this = ::std::move(from);
  }

  inline EchoMsg& operator=(const EchoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline EchoMsg& operator=(EchoMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EchoMsg& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kLoginRequest = 2,
    kLoginResponse = 3,
    kChatMsg = 4,
    kRoomAction = 5,
    kVoiceAnnounce = 6,
    kRoomActionResponse = 7,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const EchoMsg* internal_default_instance() {
    return reinterpret_cast<const EchoMsg*>(
               &_EchoMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EchoMsg& a, EchoMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(EchoMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EchoMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EchoMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EchoMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EchoMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EchoMsg& from) {
    EchoMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EchoMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "echomesh.EchoMsg";
  }
  protected:
  explicit EchoMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kLoginRequestFieldNumber = 2,
    kLoginResponseFieldNumber = 3,
    kChatMsgFieldNumber = 4,
    kRoomActionFieldNumber = 5,
    kVoiceAnnounceFieldNumber = 6,
    kRoomActionResponseFieldNumber = 7,
  };
  // .echomesh.MsgType type = 1;
  void clear_type();
  ::echomesh::MsgType type() const;
  void set_type(::echomesh::MsgType value);
  private:
  ::echomesh::MsgType _internal_type() const;
  void _internal_set_type(::echomesh::MsgType value);
  public:

  // .echomesh.LoginRequest login_request = 2;
  bool has_login_request() const;
  private:
  bool _internal_has_login_request() const;
  public:
  void clear_login_request();
  const ::echomesh::LoginRequest& login_request() const;
  PROTOBUF_NODISCARD ::echomesh::LoginRequest* release_login_request();
  ::echomesh::LoginRequest* mutable_login_request();
  void set_allocated_login_request(::echomesh::LoginRequest* login_request);
  private:
  const ::echomesh::LoginRequest& _internal_login_request() const;
  ::echomesh::LoginRequest* _internal_mutable_login_request();
  public:
  void unsafe_arena_set_allocated_login_request(
      ::echomesh::LoginRequest* login_request);
  ::echomesh::LoginRequest* unsafe_arena_release_login_request();

  // .echomesh.LoginResponse login_response = 3;
  bool has_login_response() const;
  private:
  bool _internal_has_login_response() const;
  public:
  void clear_login_response();
  const ::echomesh::LoginResponse& login_response() const;
  PROTOBUF_NODISCARD ::echomesh::LoginResponse* release_login_response();
  ::echomesh::LoginResponse* mutable_login_response();
  void set_allocated_login_response(::echomesh::LoginResponse* login_response);
  private:
  const ::echomesh::LoginResponse& _internal_login_response() const;
  ::echomesh::LoginResponse* _internal_mutable_login_response();
  public:
  void unsafe_arena_set_allocated_login_response(
      ::echomesh::LoginResponse* login_response);
  ::echomesh::LoginResponse* unsafe_arena_release_login_response();

  // .echomesh.ChatMsg chat_msg = 4;
  bool has_chat_msg() const;
  private:
  bool _internal_has_chat_msg() const;
  public:
  void clear_chat_msg();
  const ::echomesh::ChatMsg& chat_msg() const;
  PROTOBUF_NODISCARD ::echomesh::ChatMsg* release_chat_msg();
  ::echomesh::ChatMsg* mutable_chat_msg();
  void set_allocated_chat_msg(::echomesh::ChatMsg* chat_msg);
  private:
  const ::echomesh::ChatMsg& _internal_chat_msg() const;
  ::echomesh::ChatMsg* _internal_mutable_chat_msg();
  public:
  void unsafe_arena_set_allocated_chat_msg(
      ::echomesh::ChatMsg* chat_msg);
  ::echomesh::ChatMsg* unsafe_arena_release_chat_msg();

  // .echomesh.RoomAction room_action = 5;
  bool has_room_action() const;
  private:
  bool _internal_has_room_action() const;
  public:
  void clear_room_action();
  const ::echomesh::RoomAction& room_action() const;
  PROTOBUF_NODISCARD ::echomesh::RoomAction* release_room_action();
  ::echomesh::RoomAction* mutable_room_action();
  void set_allocated_room_action(::echomesh::RoomAction* room_action);
  private:
  const ::echomesh::RoomAction& _internal_room_action() const;
  ::echomesh::RoomAction* _internal_mutable_room_action();
  public:
  void unsafe_arena_set_allocated_room_action(
      ::echomesh::RoomAction* room_action);
  ::echomesh::RoomAction* unsafe_arena_release_room_action();

  // .echomesh.VoiceAnnounce voice_announce = 6;
  bool has_voice_announce() const;
  private:
  bool _internal_has_voice_announce() const;
  public:
  void clear_voice_announce();
  const ::echomesh::VoiceAnnounce& voice_announce() const;
  PROTOBUF_NODISCARD ::echomesh::VoiceAnnounce* release_voice_announce();
  ::echomesh::VoiceAnnounce* mutable_voice_announce();
  void set_allocated_voice_announce(::echomesh::VoiceAnnounce* voice_announce);
  private:
  const ::echomesh::VoiceAnnounce& _internal_voice_announce() const;
  ::echomesh::VoiceAnnounce* _internal_mutable_voice_announce();
  public:
  void unsafe_arena_set_allocated_voice_announce(
      ::echomesh::VoiceAnnounce* voice_announce);
  ::echomesh::VoiceAnnounce* unsafe_arena_release_voice_announce();

  // .echomesh.RoomActionResponse room_action_response = 7;
  bool has_room_action_response() const;
  private:
  bool _internal_has_room_action_response() const;
  public:
  void clear_room_action_response();
  const ::echomesh::RoomActionResponse& room_action_response() const;
  PROTOBUF_NODISCARD ::echomesh::RoomActionResponse* release_room_action_response();
  ::echomesh::RoomActionResponse* mutable_room_action_response();
  void set_allocated_room_action_response(::echomesh::RoomActionResponse* room_action_response);
  private:
  const ::echomesh::RoomActionResponse& _internal_room_action_response() const;
  ::echomesh::RoomActionResponse* _internal_mutable_room_action_response();
  public:
  void unsafe_arena_set_allocated_room_action_response(
      ::echomesh::RoomActionResponse* room_action_response);
  ::echomesh::RoomActionResponse* unsafe_arena_release_room_action_response();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:echomesh.EchoMsg)
 private:
  class _Internal;
  void set_has_login_request();
  void set_has_login_response();
  void set_has_chat_msg();
  void set_has_room_action();
  void set_has_voice_announce();
  void set_has_room_action_response();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::echomesh::LoginRequest* login_request_;
      ::echomesh::LoginResponse* login_response_;
      ::echomesh::ChatMsg* chat_msg_;
      ::echomesh::RoomAction* room_action_;
      ::echomesh::VoiceAnnounce* voice_announce_;
      ::echomesh::RoomActionResponse* room_action_response_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginRequest

// string username = 1;
inline void LoginRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginRequest::username() const {
  // @@protoc_insertion_point(field_get:echomesh.LoginRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:echomesh.LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:echomesh.LoginRequest.username)
  return _s;
}
inline const std::string& LoginRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LoginRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:echomesh.LoginRequest.username)
  return _impl_.username_.Release();
}
inline void LoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:echomesh.LoginRequest.username)
}

// string password = 2;
inline void LoginRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:echomesh.LoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:echomesh.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:echomesh.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:echomesh.LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:echomesh.LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginResponse

// .echomesh.StatusCode status_code = 1;
inline void LoginResponse::clear_status_code() {
  _impl_.status_code_ = 0;
}
inline ::echomesh::StatusCode LoginResponse::_internal_status_code() const {
  return static_cast< ::echomesh::StatusCode >(_impl_.status_code_);
}
inline ::echomesh::StatusCode LoginResponse::status_code() const {
  // @@protoc_insertion_point(field_get:echomesh.LoginResponse.status_code)
  return _internal_status_code();
}
inline void LoginResponse::_internal_set_status_code(::echomesh::StatusCode value) {
  
  _impl_.status_code_ = value;
}
inline void LoginResponse::set_status_code(::echomesh::StatusCode value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:echomesh.LoginResponse.status_code)
}

// int64 user_id = 2;
inline void LoginResponse::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t LoginResponse::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t LoginResponse::user_id() const {
  // @@protoc_insertion_point(field_get:echomesh.LoginResponse.user_id)
  return _internal_user_id();
}
inline void LoginResponse::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void LoginResponse::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:echomesh.LoginResponse.user_id)
}

// string message = 3;
inline void LoginResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LoginResponse::message() const {
  // @@protoc_insertion_point(field_get:echomesh.LoginResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:echomesh.LoginResponse.message)
}
inline std::string* LoginResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:echomesh.LoginResponse.message)
  return _s;
}
inline const std::string& LoginResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LoginResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_message() {
  // @@protoc_insertion_point(field_release:echomesh.LoginResponse.message)
  return _impl_.message_.Release();
}
inline void LoginResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:echomesh.LoginResponse.message)
}

// -------------------------------------------------------------------

// ChatMsg

// int64 user_id = 1;
inline void ChatMsg::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t ChatMsg::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t ChatMsg::user_id() const {
  // @@protoc_insertion_point(field_get:echomesh.ChatMsg.user_id)
  return _internal_user_id();
}
inline void ChatMsg::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void ChatMsg::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:echomesh.ChatMsg.user_id)
}

// string room_id = 2;
inline void ChatMsg::clear_room_id() {
  _impl_.room_id_.ClearToEmpty();
}
inline const std::string& ChatMsg::room_id() const {
  // @@protoc_insertion_point(field_get:echomesh.ChatMsg.room_id)
  return _internal_room_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMsg::set_room_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:echomesh.ChatMsg.room_id)
}
inline std::string* ChatMsg::mutable_room_id() {
  std::string* _s = _internal_mutable_room_id();
  // @@protoc_insertion_point(field_mutable:echomesh.ChatMsg.room_id)
  return _s;
}
inline const std::string& ChatMsg::_internal_room_id() const {
  return _impl_.room_id_.Get();
}
inline void ChatMsg::_internal_set_room_id(const std::string& value) {
  
  _impl_.room_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMsg::_internal_mutable_room_id() {
  
  return _impl_.room_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMsg::release_room_id() {
  // @@protoc_insertion_point(field_release:echomesh.ChatMsg.room_id)
  return _impl_.room_id_.Release();
}
inline void ChatMsg::set_allocated_room_id(std::string* room_id) {
  if (room_id != nullptr) {
    
  } else {
    
  }
  _impl_.room_id_.SetAllocated(room_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_id_.IsDefault()) {
    _impl_.room_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:echomesh.ChatMsg.room_id)
}

// string content = 3;
inline void ChatMsg::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& ChatMsg::content() const {
  // @@protoc_insertion_point(field_get:echomesh.ChatMsg.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMsg::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:echomesh.ChatMsg.content)
}
inline std::string* ChatMsg::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:echomesh.ChatMsg.content)
  return _s;
}
inline const std::string& ChatMsg::_internal_content() const {
  return _impl_.content_.Get();
}
inline void ChatMsg::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMsg::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMsg::release_content() {
  // @@protoc_insertion_point(field_release:echomesh.ChatMsg.content)
  return _impl_.content_.Release();
}
inline void ChatMsg::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:echomesh.ChatMsg.content)
}

// -------------------------------------------------------------------

// RoomAction

// .echomesh.RoomActionType action_type = 1;
inline void RoomAction::clear_action_type() {
  _impl_.action_type_ = 0;
}
inline ::echomesh::RoomActionType RoomAction::_internal_action_type() const {
  return static_cast< ::echomesh::RoomActionType >(_impl_.action_type_);
}
inline ::echomesh::RoomActionType RoomAction::action_type() const {
  // @@protoc_insertion_point(field_get:echomesh.RoomAction.action_type)
  return _internal_action_type();
}
inline void RoomAction::_internal_set_action_type(::echomesh::RoomActionType value) {
  
  _impl_.action_type_ = value;
}
inline void RoomAction::set_action_type(::echomesh::RoomActionType value) {
  _internal_set_action_type(value);
  // @@protoc_insertion_point(field_set:echomesh.RoomAction.action_type)
}

// string room_id = 2;
inline void RoomAction::clear_room_id() {
  _impl_.room_id_.ClearToEmpty();
}
inline const std::string& RoomAction::room_id() const {
  // @@protoc_insertion_point(field_get:echomesh.RoomAction.room_id)
  return _internal_room_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomAction::set_room_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:echomesh.RoomAction.room_id)
}
inline std::string* RoomAction::mutable_room_id() {
  std::string* _s = _internal_mutable_room_id();
  // @@protoc_insertion_point(field_mutable:echomesh.RoomAction.room_id)
  return _s;
}
inline const std::string& RoomAction::_internal_room_id() const {
  return _impl_.room_id_.Get();
}
inline void RoomAction::_internal_set_room_id(const std::string& value) {
  
  _impl_.room_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomAction::_internal_mutable_room_id() {
  
  return _impl_.room_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomAction::release_room_id() {
  // @@protoc_insertion_point(field_release:echomesh.RoomAction.room_id)
  return _impl_.room_id_.Release();
}
inline void RoomAction::set_allocated_room_id(std::string* room_id) {
  if (room_id != nullptr) {
    
  } else {
    
  }
  _impl_.room_id_.SetAllocated(room_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_id_.IsDefault()) {
    _impl_.room_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:echomesh.RoomAction.room_id)
}

// int64 user_id = 3;
inline void RoomAction::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t RoomAction::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t RoomAction::user_id() const {
  // @@protoc_insertion_point(field_get:echomesh.RoomAction.user_id)
  return _internal_user_id();
}
inline void RoomAction::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void RoomAction::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:echomesh.RoomAction.user_id)
}

// -------------------------------------------------------------------

// RoomActionResponse

// .echomesh.StatusCode status_code = 1;
inline void RoomActionResponse::clear_status_code() {
  _impl_.status_code_ = 0;
}
inline ::echomesh::StatusCode RoomActionResponse::_internal_status_code() const {
  return static_cast< ::echomesh::StatusCode >(_impl_.status_code_);
}
inline ::echomesh::StatusCode RoomActionResponse::status_code() const {
  // @@protoc_insertion_point(field_get:echomesh.RoomActionResponse.status_code)
  return _internal_status_code();
}
inline void RoomActionResponse::_internal_set_status_code(::echomesh::StatusCode value) {
  
  _impl_.status_code_ = value;
}
inline void RoomActionResponse::set_status_code(::echomesh::StatusCode value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:echomesh.RoomActionResponse.status_code)
}

// string message = 2;
inline void RoomActionResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RoomActionResponse::message() const {
  // @@protoc_insertion_point(field_get:echomesh.RoomActionResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomActionResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:echomesh.RoomActionResponse.message)
}
inline std::string* RoomActionResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:echomesh.RoomActionResponse.message)
  return _s;
}
inline const std::string& RoomActionResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RoomActionResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomActionResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomActionResponse::release_message() {
  // @@protoc_insertion_point(field_release:echomesh.RoomActionResponse.message)
  return _impl_.message_.Release();
}
inline void RoomActionResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:echomesh.RoomActionResponse.message)
}

// -------------------------------------------------------------------

// VoiceAnnounce

// string sdp = 1;
inline void VoiceAnnounce::clear_sdp() {
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& VoiceAnnounce::sdp() const {
  // @@protoc_insertion_point(field_get:echomesh.VoiceAnnounce.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoiceAnnounce::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:echomesh.VoiceAnnounce.sdp)
}
inline std::string* VoiceAnnounce::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:echomesh.VoiceAnnounce.sdp)
  return _s;
}
inline const std::string& VoiceAnnounce::_internal_sdp() const {
  return _impl_.sdp_.Get();
}
inline void VoiceAnnounce::_internal_set_sdp(const std::string& value) {
  
  _impl_.sdp_.Set(value, GetArenaForAllocation());
}
inline std::string* VoiceAnnounce::_internal_mutable_sdp() {
  
  return _impl_.sdp_.Mutable(GetArenaForAllocation());
}
inline std::string* VoiceAnnounce::release_sdp() {
  // @@protoc_insertion_point(field_release:echomesh.VoiceAnnounce.sdp)
  return _impl_.sdp_.Release();
}
inline void VoiceAnnounce::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_.SetAllocated(sdp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:echomesh.VoiceAnnounce.sdp)
}

// string room_id = 2;
inline void VoiceAnnounce::clear_room_id() {
  _impl_.room_id_.ClearToEmpty();
}
inline const std::string& VoiceAnnounce::room_id() const {
  // @@protoc_insertion_point(field_get:echomesh.VoiceAnnounce.room_id)
  return _internal_room_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoiceAnnounce::set_room_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:echomesh.VoiceAnnounce.room_id)
}
inline std::string* VoiceAnnounce::mutable_room_id() {
  std::string* _s = _internal_mutable_room_id();
  // @@protoc_insertion_point(field_mutable:echomesh.VoiceAnnounce.room_id)
  return _s;
}
inline const std::string& VoiceAnnounce::_internal_room_id() const {
  return _impl_.room_id_.Get();
}
inline void VoiceAnnounce::_internal_set_room_id(const std::string& value) {
  
  _impl_.room_id_.Set(value, GetArenaForAllocation());
}
inline std::string* VoiceAnnounce::_internal_mutable_room_id() {
  
  return _impl_.room_id_.Mutable(GetArenaForAllocation());
}
inline std::string* VoiceAnnounce::release_room_id() {
  // @@protoc_insertion_point(field_release:echomesh.VoiceAnnounce.room_id)
  return _impl_.room_id_.Release();
}
inline void VoiceAnnounce::set_allocated_room_id(std::string* room_id) {
  if (room_id != nullptr) {
    
  } else {
    
  }
  _impl_.room_id_.SetAllocated(room_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_id_.IsDefault()) {
    _impl_.room_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:echomesh.VoiceAnnounce.room_id)
}

// int64 user_id = 3;
inline void VoiceAnnounce::clear_user_id() {
  _impl_.user_id_ = int64_t{0};
}
inline int64_t VoiceAnnounce::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int64_t VoiceAnnounce::user_id() const {
  // @@protoc_insertion_point(field_get:echomesh.VoiceAnnounce.user_id)
  return _internal_user_id();
}
inline void VoiceAnnounce::_internal_set_user_id(int64_t value) {
  
  _impl_.user_id_ = value;
}
inline void VoiceAnnounce::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:echomesh.VoiceAnnounce.user_id)
}

// -------------------------------------------------------------------

// EchoMsg

// .echomesh.MsgType type = 1;
inline void EchoMsg::clear_type() {
  _impl_.type_ = 0;
}
inline ::echomesh::MsgType EchoMsg::_internal_type() const {
  return static_cast< ::echomesh::MsgType >(_impl_.type_);
}
inline ::echomesh::MsgType EchoMsg::type() const {
  // @@protoc_insertion_point(field_get:echomesh.EchoMsg.type)
  return _internal_type();
}
inline void EchoMsg::_internal_set_type(::echomesh::MsgType value) {
  
  _impl_.type_ = value;
}
inline void EchoMsg::set_type(::echomesh::MsgType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:echomesh.EchoMsg.type)
}

// .echomesh.LoginRequest login_request = 2;
inline bool EchoMsg::_internal_has_login_request() const {
  return payload_case() == kLoginRequest;
}
inline bool EchoMsg::has_login_request() const {
  return _internal_has_login_request();
}
inline void EchoMsg::set_has_login_request() {
  _impl_._oneof_case_[0] = kLoginRequest;
}
inline void EchoMsg::clear_login_request() {
  if (_internal_has_login_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.login_request_;
    }
    clear_has_payload();
  }
}
inline ::echomesh::LoginRequest* EchoMsg::release_login_request() {
  // @@protoc_insertion_point(field_release:echomesh.EchoMsg.login_request)
  if (_internal_has_login_request()) {
    clear_has_payload();
    ::echomesh::LoginRequest* temp = _impl_.payload_.login_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::echomesh::LoginRequest& EchoMsg::_internal_login_request() const {
  return _internal_has_login_request()
      ? *_impl_.payload_.login_request_
      : reinterpret_cast< ::echomesh::LoginRequest&>(::echomesh::_LoginRequest_default_instance_);
}
inline const ::echomesh::LoginRequest& EchoMsg::login_request() const {
  // @@protoc_insertion_point(field_get:echomesh.EchoMsg.login_request)
  return _internal_login_request();
}
inline ::echomesh::LoginRequest* EchoMsg::unsafe_arena_release_login_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:echomesh.EchoMsg.login_request)
  if (_internal_has_login_request()) {
    clear_has_payload();
    ::echomesh::LoginRequest* temp = _impl_.payload_.login_request_;
    _impl_.payload_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EchoMsg::unsafe_arena_set_allocated_login_request(::echomesh::LoginRequest* login_request) {
  clear_payload();
  if (login_request) {
    set_has_login_request();
    _impl_.payload_.login_request_ = login_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:echomesh.EchoMsg.login_request)
}
inline ::echomesh::LoginRequest* EchoMsg::_internal_mutable_login_request() {
  if (!_internal_has_login_request()) {
    clear_payload();
    set_has_login_request();
    _impl_.payload_.login_request_ = CreateMaybeMessage< ::echomesh::LoginRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.login_request_;
}
inline ::echomesh::LoginRequest* EchoMsg::mutable_login_request() {
  ::echomesh::LoginRequest* _msg = _internal_mutable_login_request();
  // @@protoc_insertion_point(field_mutable:echomesh.EchoMsg.login_request)
  return _msg;
}

// .echomesh.LoginResponse login_response = 3;
inline bool EchoMsg::_internal_has_login_response() const {
  return payload_case() == kLoginResponse;
}
inline bool EchoMsg::has_login_response() const {
  return _internal_has_login_response();
}
inline void EchoMsg::set_has_login_response() {
  _impl_._oneof_case_[0] = kLoginResponse;
}
inline void EchoMsg::clear_login_response() {
  if (_internal_has_login_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.login_response_;
    }
    clear_has_payload();
  }
}
inline ::echomesh::LoginResponse* EchoMsg::release_login_response() {
  // @@protoc_insertion_point(field_release:echomesh.EchoMsg.login_response)
  if (_internal_has_login_response()) {
    clear_has_payload();
    ::echomesh::LoginResponse* temp = _impl_.payload_.login_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::echomesh::LoginResponse& EchoMsg::_internal_login_response() const {
  return _internal_has_login_response()
      ? *_impl_.payload_.login_response_
      : reinterpret_cast< ::echomesh::LoginResponse&>(::echomesh::_LoginResponse_default_instance_);
}
inline const ::echomesh::LoginResponse& EchoMsg::login_response() const {
  // @@protoc_insertion_point(field_get:echomesh.EchoMsg.login_response)
  return _internal_login_response();
}
inline ::echomesh::LoginResponse* EchoMsg::unsafe_arena_release_login_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:echomesh.EchoMsg.login_response)
  if (_internal_has_login_response()) {
    clear_has_payload();
    ::echomesh::LoginResponse* temp = _impl_.payload_.login_response_;
    _impl_.payload_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EchoMsg::unsafe_arena_set_allocated_login_response(::echomesh::LoginResponse* login_response) {
  clear_payload();
  if (login_response) {
    set_has_login_response();
    _impl_.payload_.login_response_ = login_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:echomesh.EchoMsg.login_response)
}
inline ::echomesh::LoginResponse* EchoMsg::_internal_mutable_login_response() {
  if (!_internal_has_login_response()) {
    clear_payload();
    set_has_login_response();
    _impl_.payload_.login_response_ = CreateMaybeMessage< ::echomesh::LoginResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.login_response_;
}
inline ::echomesh::LoginResponse* EchoMsg::mutable_login_response() {
  ::echomesh::LoginResponse* _msg = _internal_mutable_login_response();
  // @@protoc_insertion_point(field_mutable:echomesh.EchoMsg.login_response)
  return _msg;
}

// .echomesh.ChatMsg chat_msg = 4;
inline bool EchoMsg::_internal_has_chat_msg() const {
  return payload_case() == kChatMsg;
}
inline bool EchoMsg::has_chat_msg() const {
  return _internal_has_chat_msg();
}
inline void EchoMsg::set_has_chat_msg() {
  _impl_._oneof_case_[0] = kChatMsg;
}
inline void EchoMsg::clear_chat_msg() {
  if (_internal_has_chat_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.chat_msg_;
    }
    clear_has_payload();
  }
}
inline ::echomesh::ChatMsg* EchoMsg::release_chat_msg() {
  // @@protoc_insertion_point(field_release:echomesh.EchoMsg.chat_msg)
  if (_internal_has_chat_msg()) {
    clear_has_payload();
    ::echomesh::ChatMsg* temp = _impl_.payload_.chat_msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.chat_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::echomesh::ChatMsg& EchoMsg::_internal_chat_msg() const {
  return _internal_has_chat_msg()
      ? *_impl_.payload_.chat_msg_
      : reinterpret_cast< ::echomesh::ChatMsg&>(::echomesh::_ChatMsg_default_instance_);
}
inline const ::echomesh::ChatMsg& EchoMsg::chat_msg() const {
  // @@protoc_insertion_point(field_get:echomesh.EchoMsg.chat_msg)
  return _internal_chat_msg();
}
inline ::echomesh::ChatMsg* EchoMsg::unsafe_arena_release_chat_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:echomesh.EchoMsg.chat_msg)
  if (_internal_has_chat_msg()) {
    clear_has_payload();
    ::echomesh::ChatMsg* temp = _impl_.payload_.chat_msg_;
    _impl_.payload_.chat_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EchoMsg::unsafe_arena_set_allocated_chat_msg(::echomesh::ChatMsg* chat_msg) {
  clear_payload();
  if (chat_msg) {
    set_has_chat_msg();
    _impl_.payload_.chat_msg_ = chat_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:echomesh.EchoMsg.chat_msg)
}
inline ::echomesh::ChatMsg* EchoMsg::_internal_mutable_chat_msg() {
  if (!_internal_has_chat_msg()) {
    clear_payload();
    set_has_chat_msg();
    _impl_.payload_.chat_msg_ = CreateMaybeMessage< ::echomesh::ChatMsg >(GetArenaForAllocation());
  }
  return _impl_.payload_.chat_msg_;
}
inline ::echomesh::ChatMsg* EchoMsg::mutable_chat_msg() {
  ::echomesh::ChatMsg* _msg = _internal_mutable_chat_msg();
  // @@protoc_insertion_point(field_mutable:echomesh.EchoMsg.chat_msg)
  return _msg;
}

// .echomesh.RoomAction room_action = 5;
inline bool EchoMsg::_internal_has_room_action() const {
  return payload_case() == kRoomAction;
}
inline bool EchoMsg::has_room_action() const {
  return _internal_has_room_action();
}
inline void EchoMsg::set_has_room_action() {
  _impl_._oneof_case_[0] = kRoomAction;
}
inline void EchoMsg::clear_room_action() {
  if (_internal_has_room_action()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.room_action_;
    }
    clear_has_payload();
  }
}
inline ::echomesh::RoomAction* EchoMsg::release_room_action() {
  // @@protoc_insertion_point(field_release:echomesh.EchoMsg.room_action)
  if (_internal_has_room_action()) {
    clear_has_payload();
    ::echomesh::RoomAction* temp = _impl_.payload_.room_action_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.room_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::echomesh::RoomAction& EchoMsg::_internal_room_action() const {
  return _internal_has_room_action()
      ? *_impl_.payload_.room_action_
      : reinterpret_cast< ::echomesh::RoomAction&>(::echomesh::_RoomAction_default_instance_);
}
inline const ::echomesh::RoomAction& EchoMsg::room_action() const {
  // @@protoc_insertion_point(field_get:echomesh.EchoMsg.room_action)
  return _internal_room_action();
}
inline ::echomesh::RoomAction* EchoMsg::unsafe_arena_release_room_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:echomesh.EchoMsg.room_action)
  if (_internal_has_room_action()) {
    clear_has_payload();
    ::echomesh::RoomAction* temp = _impl_.payload_.room_action_;
    _impl_.payload_.room_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EchoMsg::unsafe_arena_set_allocated_room_action(::echomesh::RoomAction* room_action) {
  clear_payload();
  if (room_action) {
    set_has_room_action();
    _impl_.payload_.room_action_ = room_action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:echomesh.EchoMsg.room_action)
}
inline ::echomesh::RoomAction* EchoMsg::_internal_mutable_room_action() {
  if (!_internal_has_room_action()) {
    clear_payload();
    set_has_room_action();
    _impl_.payload_.room_action_ = CreateMaybeMessage< ::echomesh::RoomAction >(GetArenaForAllocation());
  }
  return _impl_.payload_.room_action_;
}
inline ::echomesh::RoomAction* EchoMsg::mutable_room_action() {
  ::echomesh::RoomAction* _msg = _internal_mutable_room_action();
  // @@protoc_insertion_point(field_mutable:echomesh.EchoMsg.room_action)
  return _msg;
}

// .echomesh.VoiceAnnounce voice_announce = 6;
inline bool EchoMsg::_internal_has_voice_announce() const {
  return payload_case() == kVoiceAnnounce;
}
inline bool EchoMsg::has_voice_announce() const {
  return _internal_has_voice_announce();
}
inline void EchoMsg::set_has_voice_announce() {
  _impl_._oneof_case_[0] = kVoiceAnnounce;
}
inline void EchoMsg::clear_voice_announce() {
  if (_internal_has_voice_announce()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.voice_announce_;
    }
    clear_has_payload();
  }
}
inline ::echomesh::VoiceAnnounce* EchoMsg::release_voice_announce() {
  // @@protoc_insertion_point(field_release:echomesh.EchoMsg.voice_announce)
  if (_internal_has_voice_announce()) {
    clear_has_payload();
    ::echomesh::VoiceAnnounce* temp = _impl_.payload_.voice_announce_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.voice_announce_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::echomesh::VoiceAnnounce& EchoMsg::_internal_voice_announce() const {
  return _internal_has_voice_announce()
      ? *_impl_.payload_.voice_announce_
      : reinterpret_cast< ::echomesh::VoiceAnnounce&>(::echomesh::_VoiceAnnounce_default_instance_);
}
inline const ::echomesh::VoiceAnnounce& EchoMsg::voice_announce() const {
  // @@protoc_insertion_point(field_get:echomesh.EchoMsg.voice_announce)
  return _internal_voice_announce();
}
inline ::echomesh::VoiceAnnounce* EchoMsg::unsafe_arena_release_voice_announce() {
  // @@protoc_insertion_point(field_unsafe_arena_release:echomesh.EchoMsg.voice_announce)
  if (_internal_has_voice_announce()) {
    clear_has_payload();
    ::echomesh::VoiceAnnounce* temp = _impl_.payload_.voice_announce_;
    _impl_.payload_.voice_announce_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EchoMsg::unsafe_arena_set_allocated_voice_announce(::echomesh::VoiceAnnounce* voice_announce) {
  clear_payload();
  if (voice_announce) {
    set_has_voice_announce();
    _impl_.payload_.voice_announce_ = voice_announce;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:echomesh.EchoMsg.voice_announce)
}
inline ::echomesh::VoiceAnnounce* EchoMsg::_internal_mutable_voice_announce() {
  if (!_internal_has_voice_announce()) {
    clear_payload();
    set_has_voice_announce();
    _impl_.payload_.voice_announce_ = CreateMaybeMessage< ::echomesh::VoiceAnnounce >(GetArenaForAllocation());
  }
  return _impl_.payload_.voice_announce_;
}
inline ::echomesh::VoiceAnnounce* EchoMsg::mutable_voice_announce() {
  ::echomesh::VoiceAnnounce* _msg = _internal_mutable_voice_announce();
  // @@protoc_insertion_point(field_mutable:echomesh.EchoMsg.voice_announce)
  return _msg;
}

// .echomesh.RoomActionResponse room_action_response = 7;
inline bool EchoMsg::_internal_has_room_action_response() const {
  return payload_case() == kRoomActionResponse;
}
inline bool EchoMsg::has_room_action_response() const {
  return _internal_has_room_action_response();
}
inline void EchoMsg::set_has_room_action_response() {
  _impl_._oneof_case_[0] = kRoomActionResponse;
}
inline void EchoMsg::clear_room_action_response() {
  if (_internal_has_room_action_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.room_action_response_;
    }
    clear_has_payload();
  }
}
inline ::echomesh::RoomActionResponse* EchoMsg::release_room_action_response() {
  // @@protoc_insertion_point(field_release:echomesh.EchoMsg.room_action_response)
  if (_internal_has_room_action_response()) {
    clear_has_payload();
    ::echomesh::RoomActionResponse* temp = _impl_.payload_.room_action_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.room_action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::echomesh::RoomActionResponse& EchoMsg::_internal_room_action_response() const {
  return _internal_has_room_action_response()
      ? *_impl_.payload_.room_action_response_
      : reinterpret_cast< ::echomesh::RoomActionResponse&>(::echomesh::_RoomActionResponse_default_instance_);
}
inline const ::echomesh::RoomActionResponse& EchoMsg::room_action_response() const {
  // @@protoc_insertion_point(field_get:echomesh.EchoMsg.room_action_response)
  return _internal_room_action_response();
}
inline ::echomesh::RoomActionResponse* EchoMsg::unsafe_arena_release_room_action_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:echomesh.EchoMsg.room_action_response)
  if (_internal_has_room_action_response()) {
    clear_has_payload();
    ::echomesh::RoomActionResponse* temp = _impl_.payload_.room_action_response_;
    _impl_.payload_.room_action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EchoMsg::unsafe_arena_set_allocated_room_action_response(::echomesh::RoomActionResponse* room_action_response) {
  clear_payload();
  if (room_action_response) {
    set_has_room_action_response();
    _impl_.payload_.room_action_response_ = room_action_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:echomesh.EchoMsg.room_action_response)
}
inline ::echomesh::RoomActionResponse* EchoMsg::_internal_mutable_room_action_response() {
  if (!_internal_has_room_action_response()) {
    clear_payload();
    set_has_room_action_response();
    _impl_.payload_.room_action_response_ = CreateMaybeMessage< ::echomesh::RoomActionResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.room_action_response_;
}
inline ::echomesh::RoomActionResponse* EchoMsg::mutable_room_action_response() {
  ::echomesh::RoomActionResponse* _msg = _internal_mutable_room_action_response();
  // @@protoc_insertion_point(field_mutable:echomesh.EchoMsg.room_action_response)
  return _msg;
}

inline bool EchoMsg::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void EchoMsg::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline EchoMsg::PayloadCase EchoMsg::payload_case() const {
  return EchoMsg::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace echomesh

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::echomesh::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::echomesh::MsgType>() {
  return ::echomesh::MsgType_descriptor();
}
template <> struct is_proto_enum< ::echomesh::StatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::echomesh::StatusCode>() {
  return ::echomesh::StatusCode_descriptor();
}
template <> struct is_proto_enum< ::echomesh::RoomActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::echomesh::RoomActionType>() {
  return ::echomesh::RoomActionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
